function [Q, Omega] = simulate_rotation(T, t, J, q0, omega0, normalize, solver)
    // Rigid body rotation dynamics.
    //
    // Syntax
    //   [Q, Omega] = simulate_rotation(T, t, J, q0, omega0, normalize, solver)
    //   [Q, Omega] = simulate_rotation(T, t, J, q0, omega0, normalize)
    //   [Q, Omega] = simulate_rotation(T, t, J, q0, omega0)
    //
    // Parameters
    // Q:
    // Omega:
    // T: torque = function(t, q, omega), total torque applied in the center of mass
    // t: vector, the times at which the rigid body is simulated
    // J: matrix, the inertia matrix
    // q0: quaternion, the initial rotation/orientation
    // omega0: vector, the initial rotational speed
    // normalize: integer, number of time steps to skip before renormalizing the rotation quaternion
    // solver: string, the numerical integration solver to use ("euler", "midpoint", "implicit", "heun", "rk2" or "rk4")
    //
    // Description
    //////////////////// DESCRIPTION AND EXAMPLES AND REFERENCES ARE NOT VERIFIED
    // Simulates the rotation dynamics of a rigid body using the equation $$. talk about the equation J-1 (w - cross(J omega). say it uses the ode function. talk about normalize. list the options for the ode solver referencing ode documentation. The generated simulation can then be animated using the function "animate_top". The following is a comprehensive list of properties of an object generated by this function.
    //
    // J: Inertia matrix.
    // t: Times at which the solution has been computed.
    //
    // T: Torque over time.
    // Q: Rotation/Orientation over time.
    // Omega: Rotational speed over time.
    //
    // Examples
    // function T = torque(t, q, omega) // Null torque
    //     T = [0; 0; 0]
    // endfunction
    // [t0, dt, tf] = (0, 0.1, 10)
    // J = eye(3, 3) // Sphere
    // [q0, omega0] = (rquatd(5, %X), [0; 0; 2 * %pi])
    // [normalize, solver] = (3, "adams")
    //
    // simulation = simulate_rotation(null_torque, t0:dt:tf, J, q0, omega0, normalize, solver)
    //
    // See also
    //  animate_top
    //  ode
    //
    // Authors
    //  Arthur Clemente Giannotta ;

    // Default argument "normalize = 0"
    if ~exists("normalize", "local") then
        normalize = 0
    end

    // Default argument "solver = ''"
    if ~exists("solver", "local") then
        solver = ""
    end

    // Checks if the arguments have the correct types
    if ~%fastmode then
        //check_args("simulate_rotation(T, t, J, q, omega, normalize, solver)", T, %function, t, %vector, J, %matrix, q, %quaternion, normalize, %real)

        //if normalize <= 2 || ~is_integer(res) then// this is wrong and must be reviewed
        //    error("top(rmax, zmax, res): Resolution must be an integer bigger than 2.")
        //end

        // check J is3x3 and symmetric and real

        // check if omega0 is a column vector and warning/transpose if not

        // Check if norm(q0) = 1
    end

    // Precalculates the inverse of the inertia matrix
    invJ = inv(J)

    // The function to be integrated over time
    function q_omega_dot = dq_domega(t, q_omega)
        // Splits the current state
        [q, omega] = (q_omega(1:4), q_omega(5:7))
        [q0, q1, q2, q3] = (q(1), q(2), q(3), q(4))

        // $\dot{\vec{\omega}} = J^{-1} (\vec{T} - \vec{\omega} \times J\ \vec{\omega})$
        omega_dot = invJ * (T(t, quat(q), omega) - cross(omega, J * omega))

        // $\dot{q} = \frac{G^T \vec{\omega}}{2}$
        q_dot = [-q1, -q2, -q3;
                  q0, -q3,  q2;
                  q3,  q0, -q1;
                 -q2,  q1,  q0] * omega * 0.5

        q_omega_dot = [q_dot; omega_dot]
    endfunction

    // "normalize = n" forces a normalization whenever "modulo(i, n + 1) == 0"
    normalize = normalize + 1

    // The normalization function
    function q_omega = normalization(i, q_omega)
        if modulo(i, normalize) == 0 then
            q_omega(1:4) = q_omega(1:4) / norm(q_omega(1:4))
        end
    endfunction

    Q_Omega = numerical_integration([q0.real; q0.imag; omega0], t, dq_domega, normalization, solver)

    // Deprecated use of the Scilab function "ode"
    //Q_Omega = ode([q0.real; q0.imag; omega0], t(1), t, dq_domega)

    // Splits the integration result into Q and Omega
    Q = Q_Omega(1:4, :)
    Omega = Q_Omega(5:7, :)
endfunction
