function t = top(density, rmax, zmax, res, check)
    // Creates a spinning top.
    //
    // Syntax
    //   S = top(density, rmax, zmax, res, check)
    //   S = top(density, rmax, zmax, res)
    //
    // Parameters
    // S: top, the generated spinning top
    // density: d = function(x, z), the (x, z) density function of the top cross section
    // rmax: real, the maximum value for the radius of the top
    // zmax: real, the maximum value for the height of the top
    // res: positive integer, the rotative resolution (number of rotations when generating the surface)
    // check = true: optional boolean, true if the user should be asked to check the generated results
    //
    // Description
    // Generates an object of the spinning top class. The user will be prompted to input the cross section points. It stores all the informations required to operate with an axisymmetrical solid. Common operations are "draw_top", "rotate_top" and "translate_top". The following is a comprehensive list of properties of an object generated by this function:
    //
    // crossX: List of X coordinates for the points defining the cross section.
    // crossZ: List of Z coordinates for the points defining the cross section.
    // resolution: Rotative resolution used to generate the surface points from the cross section points.
    //
    // X: Matrix of X coordinates for the points defining the surface.
    // Y: Matrix of Y coordinates for the points defining the surface.
    // Z: Matrix of Z coordinates for the points defining the surface.
    //
    // O: Origin of the body coordinate system. Used to perform translations.
    // q: The rotation quaternion describing the current body orientation. Used to perform rotations.
    //
    // M: Mass.
    // C: Center of mass.
    // J: Inertia matrix.
    //
    // errM: Numerical error for the mass. Mass = M +- errM.
    // errC: Numerical error for the center of mass. Center of mass = C +- errC.
    // errJ: Numerical error for the inertia matrix. Inertia matrix = J +- errJ.
    //
    // style: Graphical style of the surface. Allows the usage of different colors, shading, markers, etc, when drawing the top. See the documentation of the function 'top_style' for information on how to use this.
    //
    // Examples
    // deff("d = density(x, z)", 'd = 1000')
    // S = top(density, 60, 100, 20)
    //
    // See also
    //  animate_top
    //  draw_top_cross_section
    //  draw_top
    //  rotate_top
    //  translate_top
    //
    // Authors
    //  Arthur Clemente Giannotta ;
    //
    // Bibliography
    //   Diaz, R.A., Herrera, W.J. and Martinez, R., 2004. Some powerful methods to calculate moments of inertia (No. physics/0404005).

    // Default argument "check = true"
    if ~exists("check", "local") then
        check = %true
    end

    // Checks if the arguments have the correct types
    if ~%fastmode then
        check_args("top(rmax, zmax, res, check)", rmax, %real, zmax, %real, res, %real, check, %boolean)

        if res <= 2 || ~is_integer(res) then
            error("top(rmax, zmax, res): Resolution must be an integer bigger than 2.")
        end
    end

    // Generates a figure to get the cross section as user input
    scf(); fullscreen(1)
    axes = gca()
    axes.data_bounds = [0, 0; rmax, zmax]
    axes.axes_visible = ["on", "on", "on"]
    xgrid(1)

    section = locate(-1, 1)

    // If requested, forces the starting point to be on the z axis and the end point to be on the origin
    if check && messagebox("Automatically finish the spinning top?", "Hollow Check", "question", ["Yes", "No"], "modal") == 1 then
        // This makes a hollow spinning top impossible
        section = [0, section(1, :), 0; section(2, 1), section(2, :), 0]
    end

    [x, z] = (section(1, :)', section(2, :)')
    n = size(section, 2)

    // Calculates the matrices of surface points
    [i, phi] = meshgrid(1:n, linspace(0, 2 * %pi, res))
    [Y, Z] = (matrix(x(i), res, n), matrix(z(i), res, n))

    X = cos(phi) .* Y
    Y = sin(phi) .* Y

    // Setups the integration triangles to prepare for the calculation of the moment of inertia tensor
    [intx, intz] = (zeros(3, n - 2), zeros(3, n - 2))

    // Fixes one point for all triangles
    intx(1, :) = x(1)
    intz(1, :) = z(1)

    // Get combinations of two consecutive points from the cross section polygon
    intx(2, :) = x(2:$-1)
    intx(3, :) = x(3:$)
    intz(2, :) = z(2:$-1)
    intz(3, :) = z(3:$)

    // Calculates some properties of the spinning top (mass, center of mass and moment of inertia)
    function [I, err] = properties(step)
        if step == 0 then // Mass integral = M / (2 * %pi)
            function I = dI(X, Z)
                if point_in_polygon(x, z, X, Z) then
                    I = density(X, Z) * X
                else
                    I = %superepsilon // Somehow I = 0.0 throws an error
                end
            endfunction

            property = "mass"
        elseif step == 1 then // Center of mass integral = Zc * M / (2 * %pi)
            function I = dI(X, Z)
                if point_in_polygon(x, z, X, Z) then
                    I = density(X, Z) * X * Z
                else
                    I = %superepsilon // Somehow I = 0.0 throws an error
                end
            endfunction

            property = "center of mass"
        elseif step == 2 then // Z moment of inertia integral = Iz / (2 * %pi)
            function I = dI(X, Z)
                if point_in_polygon(x, z, X, Z) then
                    I = density(X, Z) * X ** 3
                else
                    I = %superepsilon // Somehow I = 0.0 throws an error
                end
            endfunction

            property = "Z moment of inertia"
        elseif step == 3 then // X moment of inertia integral = (Ix - Iz/2) / (2 * %pi)
            function I = dI(X, Z)
                if point_in_polygon(x, z, X, Z) then
                    I = density(X, Z) * X * Z ** 2
                else
                    I = %superepsilon // Somehow I = 0.0 throws an error
                end
            endfunction

            property = "X moment of inertia"
        end

        try
            [I, err] = int2d(intx, intz, dI, [0.005, 1, 100000000, 100000000, 0])
        catch
            close()
            error("top(rmax, zmax, res): Malformed cross section. Numerical errors when evaluating the " + property + " integral.")
        end
    endfunction

    if exists("parallel_run") then
        error("The parallel functionality needs to be tested. If this error appears to you, use an older version of Sci Lab")

        result = parallel_run(0:3, properties)

        [M, errM]   = (result(1, 1), result(1, 2))
        [Zc, errZc] = (result(2, 1), result(2, 2))
        [Iz, errIz] = (result(3, 1), result(3, 2))
        [Ix, errIx] = (result(4, 1), result(4, 2))
    else
        [M, errM]   = properties(0)
        [Zc, errZc] = properties(1)
        [Iz, errIz] = properties(2)
        [Ix, errIx] = properties(3)
    end

    // For more information on the reasoning behind the following lines, take a look at the bibliography in this function documentation
    // The errors are calculated using propagation of uncertainty
    C = [0; 0; Zc / M]; errC = [0; 0; abs(C(3)) * sqrt((errZc / Zc)^2 + (errM / M)^2)]
    M = %2pi * M; errM = %2pi * errM
    Iz = %2pi * Iz; errIz = %2pi * errIz
    Ix = %2pi * Ix + 0.5 * Iz; errIx = sqrt((%2pi * errIx)^2 + (0.5 * errIz)^2)

    // Symmetry implies Ixy = Ixz = Iyz = 0 and Ix = Iy
    J = [Ix, 0, 0; 0, Ix, 0; 0, 0, Iz]
    errJ = [errIx, 0, 0; 0, errIx, 0; 0, 0, errIz]

    // Creates the spinning top object
    t = tlist(["top", "crossX", "crossZ", "resolution", "X", "Y", "Z", "O", "q", "M", "errM", "C", "errC", "J", "errJ", "style"], x, z, res, X, Y, Z, %O, rquat(0, %Z), M, errM, C, errC, J, errJ, top_style())

    // Checks with the user if the cross section and the surface of the spinning top are correct
    if check then
        draw_top_cross_section(t)

        if messagebox("Is this the desired spinning top cross section?", "Poly Check", "question", ["Yes", "No"], "modal") == 1 then
            clf()
            display([".3Dse", [-rmax, rmax], [-rmax, rmax], [0, zmax]])
            draw_top(t)

            if messagebox("Is this the desired spinning top surface?", "Surface Check", "question", ["Yes", "No"], "modal") == 1 then
                close()
                return
            end
        end

        close()
        t = top(density, rmax, zmax, res, check)
    else
        close()
    end
endfunction
